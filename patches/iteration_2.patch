diff --git a/build.gradle b/build.gradle
index cb33a47..c071849 100644
--- a/build.gradle
+++ b/build.gradle
@@ -19,17 +19,61 @@ def pluginMainClass = 'com.groupfinder.GroupFinderPluginTest'
 dependencies {
 	compileOnly group: 'net.runelite', name:'client', version: runeLiteVersion
 
+	// These are bundled inside the real RuneLite fat-jar at runtime but the
+	// stub artifact used for compilation does not include them. Declare them
+	// as compileOnly so the main sources compile, and add matching
+	// testImplementation entries so they are available on the test classpath.
+	compileOnly 'com.squareup.okhttp3:okhttp:4.12.0'
+	compileOnly 'com.google.code.gson:gson:2.11.0'
+	compileOnly 'org.slf4j:slf4j-api:2.0.16'
+	compileOnly 'javax.inject:javax.inject:1'
+
 	compileOnly 'org.projectlombok:lombok:1.18.30'
 	annotationProcessor 'org.projectlombok:lombok:1.18.30'
 
-	testImplementation 'junit:junit:4.12'
+	// Test framework
+	testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.2'
+	testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.2'
+	testRuntimeOnly  'org.junit.jupiter:junit-jupiter-engine:5.10.2'
+
+	testImplementation 'org.mockito:mockito-core:5.11.0'
+	testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'
+
+	testImplementation 'org.assertj:assertj-core:3.25.3'
+
+	testImplementation 'com.squareup.okhttp3:mockwebserver:4.12.0'
+
+	// Production classes pulled onto test classpath
 	testImplementation group: 'net.runelite', name:'client', version: runeLiteVersion
-	testImplementation group: 'net.runelite', name:'jshell', version: runeLiteVersion
+	// net.runelite:jshell is only needed for the 'run' launcher task, not for tests
+
+	// okhttp, gson, slf4j are compileOnly above; make them available for tests too
+	testImplementation 'com.squareup.okhttp3:okhttp:4.12.0'
+	testImplementation 'com.google.code.gson:gson:2.11.0'
+
+	// compileOnly deps needed at test runtime
+	// Lombok generates slf4j Logger fields — both api and simple binding required
+	testRuntimeOnly 'org.slf4j:slf4j-api:2.0.16'
+	testRuntimeOnly 'org.slf4j:slf4j-simple:2.0.16'
+	// javax.inject annotations used by production classes (@Inject, @Singleton)
+	testRuntimeOnly 'javax.inject:javax.inject:1'
 }
 
 group = 'com.groupfinder'
 version = '1.0-SNAPSHOT'
 
+// GroupFinderPluginTest is a RuneLite launcher (pluginMainClass), not a JUnit test.
+// It requires net.runelite:jshell (RuneLite, ExternalPluginManager) which is not
+// available in the stub artifact. Exclude it from test compilation so it does not
+// break the test task in offline / stub-only builds.
+compileTestJava {
+	exclude 'com/groupfinder/GroupFinderPluginTest.java'
+}
+
+test {
+	useJUnitPlatform()
+}
+
 tasks.withType(JavaCompile).configureEach {
 	options.encoding = 'UTF-8'
 	options.release.set(11)
diff --git a/src/test/java/com/groupfinder/GroupFinderPluginBehaviorTest.java b/src/test/java/com/groupfinder/GroupFinderPluginBehaviorTest.java
new file mode 100644
index 0000000..b4909a1
--- /dev/null
+++ b/src/test/java/com/groupfinder/GroupFinderPluginBehaviorTest.java
@@ -0,0 +1,679 @@
+/*
+ * Copyright (c) 2025, galst
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.groupfinder;
+
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.concurrent.ScheduledExecutorService;
+import net.runelite.api.Client;
+import net.runelite.api.FriendsChatManager;
+import net.runelite.api.GameState;
+import net.runelite.api.Player;
+import net.runelite.api.events.FriendsChatChanged;
+import net.runelite.api.events.GameStateChanged;
+import net.runelite.api.widgets.Widget;
+import net.runelite.client.callback.ClientThread;
+import net.runelite.client.chat.ChatMessageManager;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.contains;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+/**
+ * Level 2 — plugin behavior tests.
+ *
+ * Must be in package com.groupfinder (not a sub-package) because the methods
+ * under test (createGroup, deleteGroup, etc.) are package-private.
+ *
+ * startUp() is intentionally NOT called — it requires a Guice injector and
+ * loads image resources. All dependencies are injected via reflection.
+ *
+ * LENIENT strictness is used because several @BeforeEach stubs (e.g. executor
+ * synchronous answer) are intentionally not exercised in every test.
+ */
+@ExtendWith(MockitoExtension.class)
+@MockitoSettings(strictness = Strictness.LENIENT)
+class GroupFinderPluginBehaviorTest
+{
+    @Mock
+    Client mockClient;
+
+    @Mock
+    ClientThread mockClientThread;
+
+    @Mock
+    GroupFinderConfig mockConfig;
+
+    @Mock
+    GroupFinderClient mockGroupFinderClient;
+
+    @Mock
+    ChatMessageManager mockChatMessageManager;
+
+    @Mock
+    GroupFinderPanel mockPanel;
+
+    @Mock
+    ScheduledExecutorService mockExecutor;
+
+    @Mock
+    FriendsChatManager mockFcm;
+
+    @Mock
+    Player mockPlayer;
+
+    private GroupFinderPlugin plugin;
+
+    @BeforeEach
+    void setUp() throws Exception
+    {
+        plugin = new GroupFinderPlugin();
+        inject("client", mockClient);
+        inject("clientThread", mockClientThread);
+        inject("config", mockConfig);
+        inject("groupFinderClient", mockGroupFinderClient);
+        inject("chatMessageManager", mockChatMessageManager);
+        inject("panel", mockPanel);
+        inject("executorService", mockExecutor);
+
+        // Make executor run tasks synchronously so async code is deterministic
+        doAnswer(inv -> {
+            ((Runnable) inv.getArgument(0)).run();
+            return null;
+        }).when(mockExecutor).execute(any(Runnable.class));
+
+        // Make clientThread.invokeLater run synchronously
+        doAnswer(inv -> {
+            ((Runnable) inv.getArgument(0)).run();
+            return null;
+        }).when(mockClientThread).invokeLater(any(Runnable.class));
+    }
+
+    private void inject(String fieldName, Object value) throws Exception
+    {
+        Field f = GroupFinderPlugin.class.getDeclaredField(fieldName);
+        f.setAccessible(true);
+        f.set(plugin, value);
+    }
+
+    // -------------------------------------------------------------------------
+    // createGroup
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class CreateGroup
+    {
+        @Test
+        void whenPlayerIsNull_showsLoginError()
+        {
+            // Arrange
+            when(mockClient.getLocalPlayer()).thenReturn(null);
+            GroupListing listing = new GroupListing();
+
+            // Act
+            plugin.createGroup(listing);
+
+            // Assert — guard: player null → show error, API must NOT be called
+            verify(mockPanel).showError("You must be logged in to create a group");
+            verify(mockGroupFinderClient, never()).createGroup(any());
+        }
+
+        @Test
+        void whenPlayerNameIsNull_showsLoginError()
+        {
+            // Arrange
+            when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);
+            when(mockPlayer.getName()).thenReturn(null);
+            GroupListing listing = new GroupListing();
+
+            // Act
+            plugin.createGroup(listing);
+
+            // Assert
+            verify(mockPanel).showError("You must be logged in to create a group");
+            verify(mockGroupFinderClient, never()).createGroup(any());
+        }
+
+        @Test
+        void whenNoFriendsChat_showsFcError()
+        {
+            // Arrange
+            when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);
+            when(mockPlayer.getName()).thenReturn("Alice");
+            when(mockClient.getFriendsChatManager()).thenReturn(null);
+            GroupListing listing = new GroupListing();
+
+            // Act
+            plugin.createGroup(listing);
+
+            // Assert
+            verify(mockPanel).showError("Join a Friends Chat before creating a group");
+            verify(mockGroupFinderClient, never()).createGroup(any());
+        }
+
+        @Test
+        void onApiSuccess_updatesPanel()
+        {
+            // Arrange
+            when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);
+            when(mockPlayer.getName()).thenReturn("Alice");
+            when(mockClient.getFriendsChatManager()).thenReturn(mockFcm);
+            when(mockFcm.getOwner()).thenReturn("AliceFC");
+            GroupListing createdListing = GroupListingFixture.listing();
+            when(mockGroupFinderClient.createGroup(any())).thenReturn(createdListing);
+            List<GroupListing> listings = List.of(GroupListingFixture.listing());
+            when(mockGroupFinderClient.getGroups(any())).thenReturn(listings);
+
+            // Act
+            plugin.createGroup(new GroupListing());
+
+            // Assert — creation success triggers a poll which updates the panel
+            verify(mockPanel).updateListings(listings);
+        }
+
+        @Test
+        void onApiFailure_showsError()
+        {
+            // Arrange
+            when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);
+            when(mockPlayer.getName()).thenReturn("Alice");
+            when(mockClient.getFriendsChatManager()).thenReturn(mockFcm);
+            when(mockFcm.getOwner()).thenReturn("AliceFC");
+            when(mockGroupFinderClient.createGroup(any())).thenReturn(null);
+
+            // Act
+            plugin.createGroup(new GroupListing());
+
+            // Assert
+            verify(mockPanel).showError("Failed to create group");
+        }
+
+        @Test
+        void normalizesNbspInPlayerName()
+        {
+            // Arrange — player name with non-breaking space (\u00A0)
+            when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);
+            when(mockPlayer.getName()).thenReturn("Bob\u00A0Smith");
+            when(mockClient.getFriendsChatManager()).thenReturn(mockFcm);
+            when(mockFcm.getOwner()).thenReturn("OwnerFC");
+            GroupListing listing = new GroupListing();
+            when(mockGroupFinderClient.createGroup(any())).thenReturn(GroupListingFixture.listing());
+            when(mockGroupFinderClient.getGroups(any())).thenReturn(List.of());
+
+            // Act
+            plugin.createGroup(listing);
+
+            // Assert — the listing passed to the API must use a regular space
+            assertThat(listing.getPlayerName()).isEqualTo("Bob Smith");
+        }
+
+        @Test
+        void normalizesNbspInFcOwnerName()
+        {
+            // Arrange — FC owner name with non-breaking space
+            when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);
+            when(mockPlayer.getName()).thenReturn("Alice");
+            when(mockClient.getFriendsChatManager()).thenReturn(mockFcm);
+            when(mockFcm.getOwner()).thenReturn("FC\u00A0Owner");
+            GroupListing listing = new GroupListing();
+            when(mockGroupFinderClient.createGroup(any())).thenReturn(GroupListingFixture.listing());
+            when(mockGroupFinderClient.getGroups(any())).thenReturn(List.of());
+
+            // Act
+            plugin.createGroup(listing);
+
+            // Assert
+            assertThat(listing.getFriendsChatName()).isEqualTo("FC Owner");
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // deleteGroup
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class DeleteGroup
+    {
+        @Test
+        void onApiSuccess_updatesPanel()
+        {
+            // Arrange
+            List<GroupListing> listings = List.of(GroupListingFixture.listing());
+            when(mockGroupFinderClient.deleteGroup("test-id")).thenReturn(true);
+            when(mockGroupFinderClient.getGroups(any())).thenReturn(listings);
+
+            // Act
+            plugin.deleteGroup("test-id");
+
+            // Assert — deletion success triggers a poll
+            verify(mockPanel).updateListings(listings);
+        }
+
+        @Test
+        void onApiFailure_showsError()
+        {
+            // Arrange
+            when(mockGroupFinderClient.deleteGroup("test-id")).thenReturn(false);
+
+            // Act
+            plugin.deleteGroup("test-id");
+
+            // Assert
+            verify(mockPanel).showError("Failed to delete group");
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // updateGroupSize
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class UpdateGroupSize
+    {
+        @Test
+        void onApiSuccess_updatesPanel()
+        {
+            // Arrange
+            GroupListing updated = GroupListingFixture.listing();
+            updated.setCurrentSize(2);
+            List<GroupListing> listings = List.of(updated);
+            when(mockGroupFinderClient.updateGroup(any(), any())).thenReturn(updated);
+            when(mockGroupFinderClient.getGroups(any())).thenReturn(listings);
+
+            // Act
+            plugin.updateGroupSize("test-id", 2);
+
+            // Assert
+            verify(mockPanel).updateListings(listings);
+        }
+
+        @Test
+        void onApiFailure_showsError()
+        {
+            // Arrange
+            when(mockGroupFinderClient.updateGroup(any(), any())).thenReturn(null);
+
+            // Act
+            plugin.updateGroupSize("test-id", 2);
+
+            // Assert
+            verify(mockPanel).showError("Failed to update group");
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // refreshListings
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class RefreshListings
+    {
+        @Test
+        void onSuccess_updatesPanel()
+        {
+            // Arrange
+            List<GroupListing> listings = List.of(GroupListingFixture.listing());
+            when(mockGroupFinderClient.getGroups(any())).thenReturn(listings);
+
+            // Act
+            plugin.refreshListings();
+
+            // Assert
+            verify(mockPanel).updateListings(listings);
+        }
+
+        @Test
+        void whenClientThrows_showsConnectionError()
+        {
+            // Arrange
+            when(mockGroupFinderClient.getGroups(any())).thenThrow(new RuntimeException("timeout"));
+
+            // Act
+            plugin.refreshListings();
+
+            // Assert — exception is caught and surfaced to the user
+            verify(mockPanel).showError(contains("connect"));
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // onFilterChanged
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class OnFilterChanged
+    {
+        @Test
+        void passesActivityToClientOnNextPoll()
+        {
+            // Arrange
+            List<GroupListing> listings = List.of(GroupListingFixture.listing());
+            when(mockGroupFinderClient.getGroups(Activity.CHAMBERS_OF_XERIC)).thenReturn(listings);
+
+            // Act
+            plugin.onFilterChanged(Activity.CHAMBERS_OF_XERIC);
+
+            // Assert — the activity is forwarded to the HTTP client
+            verify(mockGroupFinderClient).getGroups(Activity.CHAMBERS_OF_XERIC);
+            verify(mockPanel).updateListings(listings);
+        }
+
+        @Test
+        void nullFilter_passesNullToClient()
+        {
+            // Arrange
+            List<GroupListing> listings = List.of(GroupListingFixture.listing());
+            when(mockGroupFinderClient.getGroups(null)).thenReturn(listings);
+
+            // Act
+            plugin.onFilterChanged(null);
+
+            // Assert
+            verify(mockGroupFinderClient).getGroups(null);
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // onFriendsChatChanged
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class OnFriendsChatChanged
+    {
+        @Test
+        void joined_setsInFriendsChatTrue()
+        {
+            // Arrange
+            FriendsChatChanged event = mock(FriendsChatChanged.class);
+            when(event.isJoined()).thenReturn(true);
+
+            // Act
+            plugin.onFriendsChatChanged(event);
+
+            // Assert
+            assertThat(plugin.isInFriendsChat()).isTrue();
+        }
+
+        @Test
+        void left_setsInFriendsChatFalse()
+        {
+            // Arrange — first join
+            FriendsChatChanged joinEvent = mock(FriendsChatChanged.class);
+            when(joinEvent.isJoined()).thenReturn(true);
+            plugin.onFriendsChatChanged(joinEvent);
+
+            FriendsChatChanged leaveEvent = mock(FriendsChatChanged.class);
+            when(leaveEvent.isJoined()).thenReturn(false);
+
+            // Act
+            plugin.onFriendsChatChanged(leaveEvent);
+
+            // Assert
+            assertThat(plugin.isInFriendsChat()).isFalse();
+        }
+
+        @Test
+        void whenCallbackSet_invokesCallbackOnJoin()
+        {
+            // Arrange
+            Runnable cb = mock(Runnable.class);
+            plugin.setFcStatusCallback(cb);
+            FriendsChatChanged event = mock(FriendsChatChanged.class);
+            when(event.isJoined()).thenReturn(true);
+
+            // Act
+            plugin.onFriendsChatChanged(event);
+            // SwingUtilities.invokeLater is async — flush EDT
+            try
+            {
+                javax.swing.SwingUtilities.invokeAndWait(() -> {});
+            }
+            catch (Exception ignored)
+            {
+            }
+
+            // Assert
+            verify(cb).run();
+        }
+
+        @Test
+        void whenNoCallback_doesNotThrow()
+        {
+            // Arrange — callback is null (default)
+            FriendsChatChanged event = mock(FriendsChatChanged.class);
+            when(event.isJoined()).thenReturn(true);
+
+            // Act + Assert — must not throw NullPointerException
+            plugin.onFriendsChatChanged(event);
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // onGameStateChanged
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class OnGameStateChanged
+    {
+        @ParameterizedTest
+        @EnumSource(value = GameState.class, names = {"LOGIN_SCREEN", "HOPPING"})
+        void disconnectingStates_clearInFriendsChat(GameState state)
+        {
+            // Arrange — start in FC
+            FriendsChatChanged joinEvent = mock(FriendsChatChanged.class);
+            when(joinEvent.isJoined()).thenReturn(true);
+            plugin.onFriendsChatChanged(joinEvent);
+
+            GameStateChanged event = mock(GameStateChanged.class);
+            when(event.getGameState()).thenReturn(state);
+
+            // Act
+            plugin.onGameStateChanged(event);
+
+            // Assert
+            assertThat(plugin.isInFriendsChat()).isFalse();
+        }
+
+        @ParameterizedTest
+        @EnumSource(value = GameState.class, names = {"LOGIN_SCREEN", "HOPPING"}, mode = EnumSource.Mode.EXCLUDE)
+        void otherStates_doNotClearInFriendsChat(GameState state)
+        {
+            // Arrange — start in FC
+            FriendsChatChanged joinEvent = mock(FriendsChatChanged.class);
+            when(joinEvent.isJoined()).thenReturn(true);
+            plugin.onFriendsChatChanged(joinEvent);
+
+            GameStateChanged event = mock(GameStateChanged.class);
+            when(event.getGameState()).thenReturn(state);
+
+            // Act
+            plugin.onGameStateChanged(event);
+
+            // Assert — FC state unchanged
+            assertThat(plugin.isInFriendsChat()).isTrue();
+        }
+
+        @Test
+        void loginScreen_invokesCallback()
+        {
+            // Arrange
+            Runnable cb = mock(Runnable.class);
+            plugin.setFcStatusCallback(cb);
+
+            GameStateChanged event = mock(GameStateChanged.class);
+            when(event.getGameState()).thenReturn(GameState.LOGIN_SCREEN);
+
+            // Act
+            plugin.onGameStateChanged(event);
+            try
+            {
+                javax.swing.SwingUtilities.invokeAndWait(() -> {});
+            }
+            catch (Exception ignored)
+            {
+            }
+
+            // Assert
+            verify(cb).run();
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // joinFriendsChat
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class JoinFriendsChat
+    {
+        @Test
+        void whenFcNameIsNull_doesNothing()
+        {
+            // Act
+            plugin.joinFriendsChat(null);
+
+            // Assert — clientThread must not be invoked
+            verify(mockClientThread, never()).invokeLater(any(Runnable.class));
+        }
+
+        @Test
+        void whenFcNameIsEmpty_doesNothing()
+        {
+            // Act
+            plugin.joinFriendsChat("");
+
+            // Assert
+            verify(mockClientThread, never()).invokeLater(any(Runnable.class));
+        }
+
+        @Test
+        void whenNotLoggedIn_doesNotDispatchKeys()
+        {
+            // Arrange
+            when(mockClient.getGameState()).thenReturn(GameState.LOGIN_SCREEN);
+
+            // Act — clientThread runs synchronously (see @BeforeEach stub)
+            plugin.joinFriendsChat("SomeFC");
+
+            // Assert — not logged in, so widget lookup must not happen
+            verify(mockClient, never()).getWidget(162, 42);
+        }
+
+        @Test
+        void whenDialogNotOpen_showsGuideMessage()
+        {
+            // Arrange — logged in but dialog widget absent
+            when(mockClient.getGameState()).thenReturn(GameState.LOGGED_IN);
+            // Widget 162,42 = Chatbox.MES_TEXT — null means dialog not open
+            when(mockClient.getWidget(162, 42)).thenReturn(null);
+
+            // Act
+            plugin.joinFriendsChat("SomeFC");
+
+            // Assert — guide message sent via chat
+            verify(mockChatMessageManager).queue(any());
+        }
+
+        @Test
+        void whenDialogOpenButHidden_showsGuideMessage()
+        {
+            // Arrange
+            when(mockClient.getGameState()).thenReturn(GameState.LOGGED_IN);
+            Widget hiddenWidget = mock(Widget.class);
+            when(hiddenWidget.isHidden()).thenReturn(true);
+            // Widget 162,42 = Chatbox.MES_TEXT
+            when(mockClient.getWidget(162, 42)).thenReturn(hiddenWidget);
+
+            // Act
+            plugin.joinFriendsChat("SomeFC");
+
+            // Assert — dialog not really open → show guide message
+            verify(mockChatMessageManager).queue(any());
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // getLocalPlayerName
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class GetLocalPlayerName
+    {
+        @Test
+        void whenLoggedIn_returnsNormalizedName()
+        {
+            // Arrange
+            when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);
+            when(mockPlayer.getName()).thenReturn("Bob\u00A0Smith");
+
+            // Act
+            String name = plugin.getLocalPlayerName();
+
+            // Assert
+            assertThat(name).isEqualTo("Bob Smith");
+        }
+
+        @Test
+        void whenNotLoggedIn_returnsNull()
+        {
+            // Arrange
+            when(mockClient.getLocalPlayer()).thenReturn(null);
+
+            // Act
+            String name = plugin.getLocalPlayerName();
+
+            // Assert
+            assertThat(name).isNull();
+        }
+
+        @Test
+        void whenPlayerNameIsNull_returnsNull()
+        {
+            // Arrange
+            when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);
+            when(mockPlayer.getName()).thenReturn(null);
+
+            // Act
+            String name = plugin.getLocalPlayerName();
+
+            // Assert
+            assertThat(name).isNull();
+        }
+    }
+}
diff --git a/src/test/java/com/groupfinder/GroupListingFixture.java b/src/test/java/com/groupfinder/GroupListingFixture.java
new file mode 100644
index 0000000..bf8d0aa
--- /dev/null
+++ b/src/test/java/com/groupfinder/GroupListingFixture.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2025, galst
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.groupfinder;
+
+/**
+ * Test-only factory for {@link GroupListing} instances.
+ * Lives in {@code src/test} — never imported from production code.
+ */
+final class GroupListingFixture
+{
+	private GroupListingFixture()
+	{
+	}
+
+	/** Returns a fully-populated listing owned by "Alice". */
+	static GroupListing listing()
+	{
+		GroupListing g = new GroupListing();
+		g.setId("test-id");
+		g.setPlayerName("Alice");
+		g.setFriendsChatName("AliceFC");
+		g.setActivity(Activity.CHAMBERS_OF_XERIC);
+		g.setCurrentSize(1);
+		g.setMaxSize(3);
+		g.setDescription("Test group");
+		return g;
+	}
+
+	/** Returns a listing with the given id, otherwise identical to {@link #listing()}. */
+	static GroupListing listingWithId(String id)
+	{
+		GroupListing g = listing();
+		g.setId(id);
+		return g;
+	}
+}
diff --git a/src/test/java/com/groupfinder/client/GroupFinderClientTest.java b/src/test/java/com/groupfinder/client/GroupFinderClientTest.java
new file mode 100644
index 0000000..2a45016
--- /dev/null
+++ b/src/test/java/com/groupfinder/client/GroupFinderClientTest.java
@@ -0,0 +1,462 @@
+/*
+ * Copyright (c) 2025, galst
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.groupfinder.client;
+
+import com.google.gson.Gson;
+import com.groupfinder.Activity;
+import com.groupfinder.GroupFinderClient;
+import com.groupfinder.GroupFinderConfig;
+import com.groupfinder.GroupListing;
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+import okhttp3.OkHttpClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+/**
+ * Level 3 — HTTP contract tests for {@link GroupFinderClient}.
+ *
+ * Uses MockWebServer for real TCP round-trips. Every test gets a fresh
+ * server instance so there is no shared state between tests.
+ */
+class GroupFinderClientTest
+{
+    private static final Gson GSON = new Gson();
+
+    private MockWebServer server;
+    private GroupFinderClient client;
+
+    @BeforeEach
+    void setUp() throws Exception
+    {
+        server = new MockWebServer();
+        server.start();
+
+        GroupFinderConfig config = mock(GroupFinderConfig.class);
+        when(config.serverUrl()).thenReturn("http://localhost:" + server.getPort());
+
+        client = new GroupFinderClient(new OkHttpClient(), GSON, config);
+    }
+
+    @AfterEach
+    void tearDown()
+    {
+        try
+        {
+            server.shutdown();
+        }
+        catch (IOException ignored)
+        {
+            // harmless double-shutdown if the test already shut it down
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // getGroups
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class GetGroups
+    {
+        @Test
+        void withNullFilter_noQueryParam() throws Exception
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setBody("[]").setResponseCode(200));
+
+            // Act
+            List<GroupListing> result = client.getGroups(null);
+
+            // Assert — no activity query parameter in the request URL
+            RecordedRequest req = server.takeRequest();
+            assertThat(req.getMethod()).isEqualTo("GET");
+            assertThat(req.getPath()).isEqualTo("/api/groups");
+            assertThat(result).isEmpty();
+        }
+
+        @Test
+        void withActivityFilter_appendsQueryParam() throws Exception
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setBody("[]").setResponseCode(200));
+
+            // Act
+            client.getGroups(Activity.CHAMBERS_OF_XERIC);
+
+            // Assert — enum name (not display name) used as query param
+            RecordedRequest req = server.takeRequest();
+            assertThat(req.getPath()).contains("activity=CHAMBERS_OF_XERIC");
+        }
+
+        @Test
+        void http200_parsesListingsFromBody() throws Exception
+        {
+            // Arrange — two listings in the response
+            GroupListing g1 = listing("id-1", "Alice", Activity.CHAMBERS_OF_XERIC);
+            GroupListing g2 = listing("id-2", "Bob", Activity.NEX);
+            String body = GSON.toJson(List.of(g1, g2));
+            server.enqueue(new MockResponse().setBody(body).setResponseCode(200));
+
+            // Act
+            List<GroupListing> result = client.getGroups(null);
+
+            // Assert
+            assertThat(result).hasSize(2);
+            assertThat(result.get(0).getPlayerName()).isEqualTo("Alice");
+            assertThat(result.get(1).getActivity()).isEqualTo(Activity.NEX);
+        }
+
+        @Test
+        void http4xx_returnsEmptyList() throws Exception
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setResponseCode(404));
+
+            // Act
+            List<GroupListing> result = client.getGroups(null);
+
+            // Assert — error response is handled gracefully
+            assertThat(result).isEmpty();
+        }
+
+        @Test
+        void http5xx_returnsEmptyList() throws Exception
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setResponseCode(500));
+
+            // Act
+            List<GroupListing> result = client.getGroups(null);
+
+            // Assert
+            assertThat(result).isEmpty();
+        }
+
+        @Test
+        void onNetworkFailure_returnsEmptyList() throws Exception
+        {
+            // Arrange — shut down the server so no port is listening
+            server.shutdown();
+
+            // Act
+            List<GroupListing> result = client.getGroups(null);
+
+            // Assert
+            assertThat(result).isEmpty();
+        }
+
+        @Test
+        void malformedJson_propagatesRuntimeException()
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setBody("not-json{{{").setResponseCode(200));
+
+            // Act + Assert — malformed JSON must not be silently swallowed
+            assertThatThrownBy(() -> client.getGroups(null))
+                .isInstanceOf(RuntimeException.class);
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // createGroup
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class CreateGroup
+    {
+        @Test
+        void postsToCorrectEndpoint() throws Exception
+        {
+            // Arrange
+            GroupListing created = listing("new-id", "Alice", Activity.CHAMBERS_OF_XERIC);
+            server.enqueue(new MockResponse().setBody(GSON.toJson(created)).setResponseCode(201));
+
+            // Act
+            client.createGroup(GroupListingFixtureHelper.listing());
+
+            // Assert
+            RecordedRequest req = server.takeRequest();
+            assertThat(req.getMethod()).isEqualTo("POST");
+            assertThat(req.getPath()).isEqualTo("/api/groups");
+        }
+
+        @Test
+        void http2xx_returnsParsedListing() throws Exception
+        {
+            // Arrange
+            GroupListing created = listing("new-id", "Alice", Activity.CHAMBERS_OF_XERIC);
+            server.enqueue(new MockResponse().setBody(GSON.toJson(created)).setResponseCode(201));
+
+            // Act
+            GroupListing result = client.createGroup(GroupListingFixtureHelper.listing());
+
+            // Assert
+            assertThat(result).isNotNull();
+            assertThat(result.getId()).isEqualTo("new-id");
+            assertThat(result.getPlayerName()).isEqualTo("Alice");
+        }
+
+        @Test
+        void requestBodyContainsListingFields() throws Exception
+        {
+            // Arrange
+            GroupListing input = listing("", "Alice", Activity.CHAMBERS_OF_XERIC);
+            GroupListing created = listing("new-id", "Alice", Activity.CHAMBERS_OF_XERIC);
+            server.enqueue(new MockResponse().setBody(GSON.toJson(created)).setResponseCode(201));
+
+            // Act
+            client.createGroup(input);
+
+            // Assert — body deserializes to a GroupListing with expected fields
+            RecordedRequest req = server.takeRequest();
+            GroupListing parsedBody = GSON.fromJson(req.getBody().readUtf8(), GroupListing.class);
+            assertThat(parsedBody.getPlayerName()).isEqualTo("Alice");
+            assertThat(parsedBody.getActivity()).isEqualTo(Activity.CHAMBERS_OF_XERIC);
+        }
+
+        @Test
+        void http4xx_returnsNull() throws Exception
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setResponseCode(400));
+
+            // Act
+            GroupListing result = client.createGroup(GroupListingFixtureHelper.listing());
+
+            // Assert
+            assertThat(result).isNull();
+        }
+
+        @Test
+        void onNetworkFailure_returnsNull() throws Exception
+        {
+            // Arrange
+            server.shutdown();
+
+            // Act
+            GroupListing result = client.createGroup(GroupListingFixtureHelper.listing());
+
+            // Assert
+            assertThat(result).isNull();
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // deleteGroup
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class DeleteGroup
+    {
+        @Test
+        void sendsDeleteToCorrectPath() throws Exception
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setResponseCode(204));
+
+            // Act
+            client.deleteGroup("abc-123");
+
+            // Assert
+            RecordedRequest req = server.takeRequest();
+            assertThat(req.getMethod()).isEqualTo("DELETE");
+            assertThat(req.getPath()).isEqualTo("/api/groups/abc-123");
+        }
+
+        @Test
+        void http2xx_returnsTrue() throws Exception
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setResponseCode(200));
+
+            // Act
+            boolean result = client.deleteGroup("abc-123");
+
+            // Assert
+            assertThat(result).isTrue();
+        }
+
+        @Test
+        void http4xx_returnsFalse() throws Exception
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setResponseCode(404));
+
+            // Act
+            boolean result = client.deleteGroup("abc-123");
+
+            // Assert
+            assertThat(result).isFalse();
+        }
+
+        @Test
+        void onNetworkFailure_returnsFalse() throws Exception
+        {
+            // Arrange
+            server.shutdown();
+
+            // Act
+            boolean result = client.deleteGroup("abc-123");
+
+            // Assert
+            assertThat(result).isFalse();
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // updateGroup
+    // -------------------------------------------------------------------------
+
+    @Nested
+    class UpdateGroup
+    {
+        @Test
+        void sendsPatchToCorrectPath() throws Exception
+        {
+            // Arrange
+            GroupListing updated = listing("id-1", "Alice", Activity.CHAMBERS_OF_XERIC);
+            server.enqueue(new MockResponse().setBody(GSON.toJson(updated)).setResponseCode(200));
+
+            // Act
+            client.updateGroup("id-1", Map.of("currentSize", 3));
+
+            // Assert
+            RecordedRequest req = server.takeRequest();
+            assertThat(req.getMethod()).isEqualTo("PATCH");
+            assertThat(req.getPath()).isEqualTo("/api/groups/id-1");
+        }
+
+        @Test
+        void requestBodyContainsFields() throws Exception
+        {
+            // Arrange
+            GroupListing updated = listing("id-1", "Alice", Activity.CHAMBERS_OF_XERIC);
+            server.enqueue(new MockResponse().setBody(GSON.toJson(updated)).setResponseCode(200));
+
+            // Act
+            client.updateGroup("id-1", Map.of("currentSize", 3));
+
+            // Assert — body deserializes correctly
+            RecordedRequest req = server.takeRequest();
+            @SuppressWarnings("unchecked")
+            Map<String, Object> parsedBody = GSON.fromJson(req.getBody().readUtf8(), Map.class);
+            // Gson deserializes numbers as Double by default
+            assertThat(((Number) parsedBody.get("currentSize")).intValue()).isEqualTo(3);
+        }
+
+        @Test
+        void http2xx_returnsParsedListing() throws Exception
+        {
+            // Arrange
+            GroupListing updated = listing("id-1", "Alice", Activity.CHAMBERS_OF_XERIC);
+            updated.setCurrentSize(3);
+            server.enqueue(new MockResponse().setBody(GSON.toJson(updated)).setResponseCode(200));
+
+            // Act
+            GroupListing result = client.updateGroup("id-1", Map.of("currentSize", 3));
+
+            // Assert
+            assertThat(result).isNotNull();
+            assertThat(result.getCurrentSize()).isEqualTo(3);
+        }
+
+        @Test
+        void http4xx_returnsNull() throws Exception
+        {
+            // Arrange
+            server.enqueue(new MockResponse().setResponseCode(404));
+
+            // Act
+            GroupListing result = client.updateGroup("id-1", Map.of("currentSize", 3));
+
+            // Assert
+            assertThat(result).isNull();
+        }
+
+        @Test
+        void onNetworkFailure_returnsNull() throws Exception
+        {
+            // Arrange
+            server.shutdown();
+
+            // Act
+            GroupListing result = client.updateGroup("id-1", Map.of("currentSize", 3));
+
+            // Assert
+            assertThat(result).isNull();
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // Helpers
+    // -------------------------------------------------------------------------
+
+    private static GroupListing listing(String id, String playerName, Activity activity)
+    {
+        GroupListing g = new GroupListing();
+        g.setId(id);
+        g.setPlayerName(playerName);
+        g.setFriendsChatName(playerName + "FC");
+        g.setActivity(activity);
+        g.setCurrentSize(1);
+        g.setMaxSize(4);
+        return g;
+    }
+
+    /**
+     * Local alias for the test fixture helper so the client test package can
+     * reference it without depending on the com.groupfinder package-private class.
+     */
+    static final class GroupListingFixtureHelper
+    {
+        private GroupListingFixtureHelper()
+        {
+        }
+
+        static GroupListing listing()
+        {
+            GroupListing g = new GroupListing();
+            g.setId("test-id");
+            g.setPlayerName("Alice");
+            g.setFriendsChatName("AliceFC");
+            g.setActivity(Activity.CHAMBERS_OF_XERIC);
+            g.setCurrentSize(1);
+            g.setMaxSize(3);
+            g.setDescription("Test group");
+            return g;
+        }
+    }
+}
diff --git a/src/test/java/com/groupfinder/unit/ActivityTest.java b/src/test/java/com/groupfinder/unit/ActivityTest.java
new file mode 100644
index 0000000..d3f08e7
--- /dev/null
+++ b/src/test/java/com/groupfinder/unit/ActivityTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2025, galst
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.groupfinder.unit;
+
+import com.groupfinder.Activity;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Level 1 — pure unit tests for the {@link Activity} enum.
+ * No RuneLite APIs, no mocks, no network.
+ */
+class ActivityTest
+{
+	/**
+	 * Contract: {@link Activity#toString()} must return the human-readable
+	 * displayName, NOT the enum constant name (e.g. "Chambers of Xeric",
+	 * not "CHAMBERS_OF_XERIC").
+	 */
+	@ParameterizedTest
+	@EnumSource(Activity.class)
+	void toString_equalsDisplayName(Activity activity)
+	{
+		assertThat(activity.toString()).isEqualTo(activity.getDisplayName());
+	}
+
+	/**
+	 * Contract: every Activity constant must have a non-null, non-blank
+	 * displayName so it can be safely rendered in the UI.
+	 */
+	@ParameterizedTest
+	@EnumSource(Activity.class)
+	void displayName_isNotBlank(Activity activity)
+	{
+		assertThat(activity.getDisplayName())
+			.as("displayName for %s", activity.name())
+			.isNotBlank();
+	}
+}
